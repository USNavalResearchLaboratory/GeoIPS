import logging
import os
try:
    import numexpr
except:
    print 'Failed numexpr import in msg xpif reader.  If numexpr is not installed and you need it, install it.'
from collections import Hashable
from datetime import datetime
from glob import glob
from subprocess import call
import numpy as np
from zipfile import ZipFile
from scipy import interpolate as interpol
from pyresample.geometry import SwathDefinition
from pyresample.kd_tree import get_neighbour_info

from .reader import Reader
from ..containers import _empty_varinfo
from geoips.utils.path.datafilename import DataFileName
from geoips.utils.satellite_info import SatSensorInfo
from geoips.utils.plugin_paths import paths as gpaths
# from .geoloc_fnames import get_geolocation_filename

from geoips.utils.log_setup import interactive_log_setup

from IPython import embed as shell

try:
    nprocs = 6
    numexpr.set_num_threads(nprocs)
except:
    print 'Failed numexpr.set_num_threads.  If numexpr is not installed and you need it, install it.'


log = interactive_log_setup(logging.getLogger(__name__))

SCRATCH = os.getenv('SCRATCH')

reader_class_name = 'MSG_XPIF_Reader'


class AutoGenError(Exception):
    pass


DONT_AUTOGEN_GEOLOCATION = False
if os.getenv('DONT_AUTOGEN_GEOLOCATION'):
    DONT_AUTOGEN_GEOLOCATION = True

GEOLOCDIR = os.path.join(gpaths['SATOPS'], 'longterm_files', 'geolocation', 'SEVIRI')
if os.getenv('GEOLOCDIR'):
    GEOLOCDIR = os.path.join(os.getenv('GEOLOCDIR'), 'SEVIRI')

DYNAMIC_GEOLOCDIR = os.path.join(gpaths['SATOPS'], 'intermediate_files', 'geolocation', 'SEVIRI')
if os.getenv('DYNAMIC_GEOLOCDIR'):
    DYNAMIC_GEOLOCDIR = os.path.join(os.getenv('DYNAMIC_GEOLOCDIR'), 'SEVIRI')

READ_GEOLOCDIRS = []
if os.getenv('READ_GEOLOCDIRS'):
    READ_GEOLOCDIRS = [os.path.join(pp, 'AHI') for pp in os.getenv('READ_GEOLOCDIRS').split(':')]

# These should be added to the data file object
BADVALS = {'Off_Of_Disk': -999.9,
           'Error': -999.8,
           'Out_Of_Valid_Range': -999.7,
           'Root_Test': -999.6,
           'Unitialized': -9999.9}

CHANNEL_MAP = {'VIS_0_6_RAW': 'B01',
               'VIS_0_8_RAW': 'B02',
               'IR_1_6_RAW': 'B03',
               'IR_3_9_RAW': 'B04',
               'WV_6_2_RAW': 'B05',
               'WV_7_3_RAW': 'B06',
               'IR_8_7_RAW': 'B07',
               'IR_9_7_RAW': 'B08',
               'IR_10_8_RAW': 'B09',
               'IR_12_0_RAW': 'B10',
               'IR_13_4_RAW': 'B11',
               # 'HRV_RAW': 'B12',
               }

CAL_RAD2REF = {'MSG1': {'B01': 20.76322655, 'B02': 23.24066423, 'B03': 19.85346507},
               'MSG2': {'B01': 20.75587359, 'B02': 23.29611381, 'B03': 19.73276196},
               'MSG3': {'B01': 20.85400853, 'B02': 23.29414029, 'B03': 19.74183379},
               'MSG4': {'B01': 20.77468571, 'B02': 23.29047972, 'B03': 19.71662365}
               }

# For interpolation of radiances to BT (0K-350K in 5K steps)
CAL_EBBT = np.arange(100, 355, 5)

CAL_RAD2BT = {'MSG1': {'B04': [-2.374066E+01, -2.207009E+01, -2.054882E+01, -1.915760E+01, -1.788034E+01,
                               -1.670354E+01, -1.561572E+01, -1.460712E+01, -1.366935E+01, -1.279518E+01,
                               -1.197832E+01, -1.121329E+01, -1.049530E+01, -9.820115E+00, -9.184017E+00,
                               -8.583694E+00, -8.016202E+00, -7.478912E+00, -6.969470E+00, -6.485762E+00,
                               -6.025880E+00, -5.588104E+00, -5.170874E+00, -4.772773E+00, -4.392515E+00,
                               -4.028924E+00, -3.680925E+00, -3.347535E+00, -3.027853E+00, -2.721049E+00,
                               -2.426359E+00, -2.143079E+00, -1.870558E+00, -1.608194E+00, -1.355428E+00,
                               -1.111744E+00, -8.766596E-01, -6.497275E-01, -4.305305E-01, -2.186792E-01,
                               -1.381043E-02, +1.844158E-01, +3.763176E-01, +5.621931E-01, +7.423220E-01,
                               +9.169669E-01, +1.086375E+00, +1.250778E+00, +1.410395E+00, +1.565432E+00,
                               +1.716083E+00],
                       'B05': [-1.180877E+01, -1.075203E+01, -9.789893E+00, -8.910184E+00, -8.102723E+00,
                               -7.358946E+00, -6.671594E+00, -6.034470E+00, -5.442255E+00, -4.890356E+00,
                               -4.374786E+00, -3.892069E+00, -3.439159E+00, -3.013373E+00, -2.612344E+00,
                               -2.233972E+00, -1.876388E+00, -1.537923E+00, -1.217083E+00, -9.125240E-01,
                               -6.230372E-01, -3.475298E-01, -8.501207E-02, +1.654142E-01, +4.045661E-01,
                               +6.331893E-01, +8.519645E-01, +1.061516E+00, +1.262414E+00, +1.455187E+00,
                               +1.640317E+00, +1.818251E+00, +1.989401E+00, +2.154149E+00, +2.312848E+00,
                               +2.465827E+00, +2.613389E+00, +2.755819E+00, +2.893380E+00, +3.026320E+00,
                               +3.154867E+00, +3.279237E+00, +3.399632E+00, +3.516240E+00, +3.629238E+00,
                               +3.738792E+00, +3.845059E+00, +3.948184E+00, +4.048307E+00, +4.145559E+00,
                               +4.240061E+00],
                       'B06': [-9.210493E+00, -8.284929E+00, -7.443160E+00, -6.674300E+00, -5.969268E+00,
                               -5.320433E+00, -4.721333E+00, -4.166460E+00, -3.651091E+00, -3.171151E+00,
                               -2.723110E+00, -2.303888E+00, -1.910792E+00, -1.541452E+00, -1.193778E+00,
                               -8.659179E-01, -5.562238E-01, -2.632262E-01, +1.439003E-02, +2.778060E-01,
                               +5.280846E-01, +7.661855E-01, +9.929770E-01, +1.209247E+00, +1.415713E+00,
                               +1.613027E+00, +1.801786E+00, +1.982535E+00, +2.155775E+00, +2.321966E+00,
                               +2.481531E+00, +2.634859E+00, +2.782311E+00, +2.924220E+00, +3.060894E+00,
                               +3.192619E+00, +3.319661E+00, +3.442266E+00, +3.560666E+00, +3.675075E+00,
                               +3.785691E+00, +3.892705E+00, +3.996289E+00, +4.096608E+00, +4.193816E+00,
                               +4.288058E+00, +4.379468E+00, +4.468175E+00, +4.554298E+00, +4.637950E+00,
                               +4.719240E+00],
                       'B07': [-6.707836E+00, -5.922936E+00, -5.209282E+00, -4.557594E+00, -3.960136E+00,
                               -3.410410E+00, -2.902916E+00, -2.432966E+00, -1.996541E+00, -1.590179E+00,
                               -1.210875E+00, -8.560136E-01, -5.233045E-01, -2.107355E-01, +8.346976E-02,
                               +3.608844E-01, +6.229073E-01, +8.707866E-01, +1.105639E+00, +1.328467E+00,
                               +1.540172E+00, +1.741570E+00, +1.933397E+00, +2.116323E+00, +2.290954E+00,
                               +2.457846E+00, +2.617504E+00, +2.770391E+00, +2.916932E+00, +3.057516E+00,
                               +3.192503E+00, +3.322223E+00, +3.446982E+00, +3.567061E+00, +3.682723E+00,
                               +3.794209E+00, +3.901745E+00, +4.005540E+00, +4.105789E+00, +4.202674E+00,
                               +4.296364E+00, +4.387018E+00, +4.474784E+00, +4.559801E+00, +4.642199E+00,
                               +4.722100E+00, +4.799619E+00, +4.874863E+00, +4.947935E+00, +5.018929E+00,
                               +5.087935E+00],
                       'B08': [-5.388653E+00, -4.680710E+00, -4.037091E+00, -3.449410E+00, -2.910677E+00,
                               -2.415022E+00, -1.957475E+00, -1.533804E+00, -1.140380E+00, -7.740746E-01,
                               -4.321756E-01, -1.123212E-01, +1.875559E-01, +4.692725E-01, +7.344320E-01,
                               +9.844549E-01, +1.220604E+00, +1.444005E+00, +1.655666E+00, +1.856493E+00,
                               +2.047300E+00, +2.228821E+00, +2.401723E+00, +2.566608E+00, +2.724025E+00,
                               +2.874475E+00, +3.018413E+00, +3.156258E+00, +3.288393E+00, +3.415169E+00,
                               +3.536910E+00, +3.653914E+00, +3.766457E+00, +3.874793E+00, +3.979157E+00,
                               +4.079770E+00, +4.176832E+00, +4.270534E+00, +4.361049E+00, +4.448544E+00,
                               +4.533169E+00, +4.615068E+00, +4.694374E+00, +4.771212E+00, +4.845700E+00,
                               +4.917946E+00, +4.988056E+00, +5.056124E+00, +5.122243E+00, +5.186498E+00,
                               +5.248971E+00],
                       'B09': [-4.160638E+00, -3.529463E+00, -2.955364E+00, -2.430933E+00, -1.949991E+00,
                               -1.507340E+00, -1.098583E+00, -7.199671E-01, -3.682753E-01, -4.073162E-02,
                               +2.650714E-01, +5.512319E-01, +8.195870E-01, +1.071752E+00, +1.309154E+00,
                               +1.533055E+00, +1.744582E+00, +1.944736E+00, +2.134415E+00, +2.314427E+00,
                               +2.485497E+00, +2.648280E+00, +2.803371E+00, +2.951307E+00, +3.092578E+00,
                               +3.227629E+00, +3.356870E+00, +3.480671E+00, +3.599376E+00, +3.713299E+00,
                               +3.822728E+00, +3.927929E+00, +4.029149E+00, +4.126614E+00, +4.220535E+00,
                               +4.311108E+00, +4.398513E+00, +4.482919E+00, +4.564482E+00, +4.643349E+00,
                               +4.719656E+00, +4.793530E+00, +4.865090E+00, +4.934449E+00, +5.001709E+00,
                               +5.066970E+00, +5.130324E+00, +5.191856E+00, +5.251649E+00, +5.309778E+00,
                               +5.366316E+00],
                       'B10': [-3.186956E+00, -2.615311E+00, -2.095456E+00, -1.620657E+00, -1.185297E+00,
                               -7.846552E-01, -4.147349E-01, -7.212920E-02, +2.460836E-01, +5.424238E-01,
                               +8.190765E-01, +1.077946E+00, +1.320700E+00, +1.548803E+00, +1.763550E+00,
                               +1.966087E+00, +2.157434E+00, +2.338501E+00, +2.510101E+00, +2.672966E+00,
                               +2.827754E+00, +2.975058E+00, +3.115417E+00, +3.249318E+00, +3.377203E+00,
                               +3.499479E+00, +3.616512E+00, +3.728641E+00, +3.836174E+00, +3.939397E+00,
                               +4.038569E+00, +4.133933E+00, +4.225709E+00, +4.314105E+00, +4.399308E+00,
                               +4.481496E+00, +4.560832E+00, +4.637468E+00, +4.711546E+00, +4.783197E+00,
                               +4.852544E+00, +4.919702E+00, +4.984779E+00, +5.047874E+00, +5.109082E+00,
                               +5.168491E+00, +5.226184E+00, +5.282239E+00, +5.336729E+00, +5.389723E+00,
                               +5.441285E+00],
                       'B11': [-2.252821E+00, -1.741917E+00, -1.277232E+00, -8.527601E-01, -4.634930E-01,
                               -1.052197E-01, +2.256266E-01, +5.320861E-01, +8.167673E-01, +1.081920E+00,
                               +1.329497E+00, +1.561197E+00, +1.778511E+00, +1.982748E+00, +2.175065E+00,
                               +2.356485E+00, +2.527919E+00, +2.690181E+00, +2.843999E+00, +2.990025E+00,
                               +3.128847E+00, +3.260996E+00, +3.386952E+00, +3.507150E+00, +3.621988E+00,
                               +3.731824E+00, +3.836989E+00, +3.937784E+00, +4.034484E+00, +4.127344E+00,
                               +4.216596E+00, +4.302455E+00, +4.385118E+00, +4.464770E+00, +4.541579E+00,
                               +4.615703E+00, +4.687286E+00, +4.756464E+00, +4.823364E+00, +4.888103E+00,
                               +4.950789E+00, +5.011525E+00, +5.070407E+00, +5.127524E+00, +5.182960E+00,
                               +5.236792E+00, +5.289095E+00, +5.339938E+00, +5.389386E+00, +5.437500E+00,
                               +5.484337E+00]
                       },
              'MSG2': {'B04': [-2.376114E+01, -2.208972E+01, -2.056760E+01, -1.917556E+01, -1.789753E+01,
                               -1.672000E+01, -1.563150E+01, -1.462227E+01, -1.368392E+01, -1.280921E+01,
                               -1.199185E+01, -1.122636E+01, -1.050794E+01, -9.832355E+00, -9.195882E+00,
                               -8.595208E+00, -8.027388E+00, -7.489789E+00, -6.980056E+00, -6.496073E+00,
                               -6.035931E+00, -5.597908E+00, -5.180443E+00, -4.782119E+00, -4.401648E+00,
                               -4.037852E+00, -3.689659E+00, -3.356082E+00, -3.036221E+00, -2.729244E+00,
                               -2.434388E+00, -2.150948E+00, -1.878272E+00, -1.615758E+00, -1.362848E+00,
                               -1.119024E+00, -8.838043E-01, -6.567408E-01, -4.374163E-01, -2.254413E-01,
                               -2.045233E-02, +1.778908E-01, +3.699064E-01, +5.558926E-01, +7.361294E-01,
                               +9.108795E-01, +1.080390E+00, +1.244893E+00, +1.404607E+00, +1.559739E+00,
                               +1.710484E+00],
                       'B05': [-1.183718E+01, -1.077898E+01, -9.815512E+00, -8.934579E+00, -8.125990E+00,
                               -7.381169E+00, -6.692846E+00, -6.054819E+00, -5.461761E+00, -4.909072E+00,
                               -4.392763E+00, -3.909350E+00, -3.455785E+00, -3.029382E+00, -2.627770E+00,
                               -2.248846E+00, -1.890740E+00, -1.551779E+00, -1.230468E+00, -9.254609E-01,
                               -6.355478E-01, -3.596339E-01, -9.672854E-02, +1.540680E-01, +3.935740E-01,
                               +6.225359E-01, +8.416357E-01, +1.051498E+00, +1.252695E+00, +1.445754E+00,
                               +1.631159E+00, +1.809358E+00, +1.980762E+00, +2.145756E+00, +2.304691E+00,
                               +2.457898E+00, +2.605680E+00, +2.748322E+00, +2.886088E+00, +3.019225E+00,
                               +3.147964E+00, +3.272520E+00, +3.393094E+00, +3.509875E+00, +3.623041E+00,
                               +3.732758E+00, +3.839182E+00, +3.942461E+00, +4.042733E+00, +4.140128E+00,
                               +4.234770E+00],
                       'B06': [-9.190554E+00, -8.266055E+00, -7.425259E+00, -6.657291E+00, -5.953081E+00,
                               -5.305005E+00, -4.706608E+00, -4.152388E+00, -3.637628E+00, -3.158257E+00,
                               -2.710748E+00, -2.292025E+00, -1.899398E+00, -1.530501E+00, -1.183244E+00,
                               -8.557777E-01, -5.464566E-01, -2.538127E-01, +2.346800E-02, +2.865648E-01,
                               +5.365397E-01, +7.743512E-01, +1.000867E+00, +1.216874E+00, +1.423088E+00,
                               +1.620161E+00, +1.808689E+00, +1.989217E+00, +2.162245E+00, +2.328232E+00,
                               +2.487600E+00, +2.640740E+00, +2.788011E+00, +2.929745E+00, +3.066251E+00,
                               +3.197814E+00, +3.324700E+00, +3.447155E+00, +3.565409E+00, +3.679676E+00,
                               +3.790157E+00, +3.897038E+00, +4.000495E+00, +4.100691E+00, +4.197779E+00,
                               +4.291905E+00, +4.383203E+00, +4.471800E+00, +4.557818E+00, +4.641368E+00,
                               +4.722558E+00],
                       'B07': [-6.702615E+00, -5.918020E+00, -5.204643E+00, -4.553206E+00, -3.955980E+00,
                               -3.406467E+00, -2.899168E+00, -2.429399E+00, -1.993143E+00, -1.586938E+00,
                               -1.207780E+00, -8.530551E-01, -5.204741E-01, -2.080254E-01, +8.606649E-02,
                               +3.633744E-01, +6.252965E-01, +8.730804E-01, +1.107842E+00, +1.330584E+00,
                               +1.542208E+00, +1.743529E+00, +1.935282E+00, +2.118138E+00, +2.292702E+00,
                               +2.459530E+00, +2.619127E+00, +2.771955E+00, +2.918440E+00, +3.058970E+00,
                               +3.193906E+00, +3.323576E+00, +3.448287E+00, +3.568320E+00, +3.683938E+00,
                               +3.795382E+00, +3.902877E+00, +4.006632E+00, +4.106843E+00, +4.203691E+00,
                               +4.297346E+00, +4.387966E+00, +4.475699E+00, +4.560684E+00, +4.643051E+00,
                               +4.722922E+00, +4.800412E+00, +4.875628E+00, +4.948672E+00, +5.019640E+00,
                               +5.088621E+00],
                       'B08': [-5.400001E+00, -4.691355E+00, -4.047101E+00, -3.458842E+00, -2.919582E+00,
                               -2.423444E+00, -1.965452E+00, -1.541371E+00, -1.147567E+00, -7.809084E-01,
                               -4.386809E-01, -1.185197E-01, +1.816444E-01, +4.636300E-01, +7.290422E-01,
                               +9.793028E-01, +1.215676E+00, +1.439289E+00, +1.651151E+00, +1.852167E+00,
                               +2.043154E+00, +2.224846E+00, +2.397910E+00, +2.562949E+00, +2.720514E+00,
                               +2.871104E+00, +3.015177E+00, +3.153150E+00, +3.285407E+00, +3.412301E+00,
                               +3.534154E+00, +3.651266E+00, +3.763912E+00, +3.872348E+00, +3.976808E+00,
                               +4.077512E+00, +4.174663E+00, +4.268449E+00, +4.359047E+00, +4.446621E+00,
                               +4.531322E+00, +4.613295E+00, +4.692672E+00, +4.769579E+00, +4.844133E+00,
                               +4.916444E+00, +4.986615E+00, +5.054743E+00, +5.120921E+00, +5.185232E+00,
                               +5.247759E+00],
                       'B09': [-4.170964E+00, -3.539218E+00, -2.964594E+00, -2.439677E+00, -1.958285E+00,
                               -1.515217E+00, -1.106071E+00, -7.270921E-01, -3.750607E-01, -4.719864E-02,
                               +2.589034E-01, +5.453452E-01, +8.139655E-01, +1.066381E+00, +1.304019E+00,
                               +1.528145E+00, +1.739884E+00, +1.940239E+00, +2.130111E+00, +2.310305E+00,
                               +2.481549E+00, +2.644498E+00, +2.799746E+00, +2.947833E+00, +3.089248E+00,
                               +3.224438E+00, +3.353811E+00, +3.477740E+00, +3.596566E+00, +3.710606E+00,
                               +3.820146E+00, +3.925455E+00, +4.026779E+00, +4.124344E+00, +4.218361E+00,
                               +4.309027E+00, +4.396521E+00, +4.481013E+00, +4.562659E+00, +4.641606E+00,
                               +4.717990E+00, +4.791939E+00, +4.863572E+00, +4.933001E+00, +5.000329E+00,
                               +5.065656E+00, +5.129073E+00, +5.190667E+00, +5.250519E+00, +5.308706E+00,
                               +5.365300E+00],
                       'B10': [-3.151583E+00, -2.582207E+00, -2.064413E+00, -1.591493E+00, -1.157854E+00,
                               -7.587934E-01, -3.903310E-01, -4.907371E-02, +2.678885E-01, +5.630656E-01,
                               +8.386343E-01, +1.096491E+00, +1.338296E+00, +1.565510E+00, +1.779421E+00,
                               +1.981171E+00, +2.171776E+00, +2.352142E+00, +2.523079E+00, +2.685317E+00,
                               +2.839509E+00, +2.986248E+00, +3.126070E+00, +3.259460E+00, +3.386859E+00,
                               +3.508670E+00, +3.625261E+00, +3.736967E+00, +3.844096E+00, +3.946932E+00,
                               +4.045734E+00, +4.140743E+00, +4.232180E+00, +4.320248E+00, +4.405138E+00,
                               +4.487025E+00, +4.566072E+00, +4.642429E+00, +4.716238E+00, +4.787632E+00,
                               +4.856730E+00, +4.923648E+00, +4.988493E+00, +5.051364E+00, +5.112357E+00,
                               +5.171557E+00, +5.229049E+00, +5.284909E+00, +5.339210E+00, +5.392021E+00,
                               +5.443407E+00],
                       'B11': [-2.247900E+00, -1.737255E+00, -1.272814E+00, -8.485721E-01, -4.595209E-01,
                               -1.014507E-01, +2.292043E-01, +5.354834E-01, +8.199944E-01, +1.084987E+00,
                               +1.332411E+00, +1.563968E+00, +1.781146E+00, +1.985253E+00, +2.177447E+00,
                               +2.358750E+00, +2.530074E+00, +2.692231E+00, +2.845948E+00, +2.991878E+00,
                               +3.130608E+00, +3.262670E+00, +3.388542E+00, +3.508661E+00, +3.623422E+00,
                               +3.733185E+00, +3.838280E+00, +3.939008E+00, +4.035644E+00, +4.128442E+00,
                               +4.217634E+00, +4.303435E+00, +4.386044E+00, +4.465643E+00, +4.542401E+00,
                               +4.616475E+00, +4.688011E+00, +4.757144E+00, +4.823999E+00, +4.888695E+00,
                               +4.951341E+00, +5.012037E+00, +5.070881E+00, +5.127961E+00, +5.183360E+00,
                               +5.237158E+00, +5.289427E+00, +5.340238E+00, +5.389654E+00, +5.437737E+00,
                               +5.484546E+00],
                       },
              'MSG3': {'B04': [-2.375045E+01, -2.207848E+01, -2.055602E+01, -1.916378E+01, -1.788565E+01,
                               -1.670810E+01, -1.561964E+01, -1.461048E+01, -1.367224E+01, -1.279765E+01,
                               -1.198043E+01, -1.121509E+01, -1.049683E+01, -9.821408E+00, -9.185104E+00,
                               -8.584600E+00, -8.016950E+00, -7.479522E+00, -6.969959E+00, -6.486145E+00,
                               -6.026170E+00, -5.588311E+00, -5.171009E+00, -4.772846E+00, -4.392532E+00,
                               -4.028892E+00, -3.680850E+00, -3.347423E+00, -3.027708E+00, -2.720875E+00,
                               -2.426160E+00, -2.142858E+00, -1.870318E+00, -1.607937E+00, -1.355157E+00,
                               -1.111461E+00, -8.763658E-01, -6.494248E-01, -4.302204E-01, -2.183630E-01,
                               -1.348922E-02, +1.847410E-01, +3.766459E-01, +5.625237E-01, +7.426541E-01,
                               +9.173000E-01, +1.086708E+00, +1.251111E+00, +1.410728E+00, +1.565763E+00,
                               +1.716414E+00],
                       'B05': [-1.180683E+01, -1.075008E+01, -9.787953E+00, -8.908264E+00, -8.100830E+00,
                               -7.357084E+00, -6.669765E+00, -6.032674E+00, -5.440493E+00, -4.888628E+00,
                               -4.373092E+00, -3.890409E+00, -3.437531E+00, -3.011777E+00, -2.610780E+00,
                               -2.232439E+00, -1.874885E+00, -1.536450E+00, -1.215639E+00, -9.111087E-01,
                               -6.216497E-01, -3.461697E-01, -8.367888E-02, +1.667210E-01, +4.058472E-01,
                               +6.344451E-01, +8.531955E-01, +1.062722E+00, +1.263597E+00, +1.456346E+00,
                               +1.641453E+00, +1.819365E+00, +1.990493E+00, +2.155220E+00, +2.313898E+00,
                               +2.466855E+00, +2.614398E+00, +2.756807E+00, +2.894349E+00, +3.027269E+00,
                               +3.155798E+00, +3.280150E+00, +3.400527E+00, +3.517117E+00, +3.630097E+00,
                               +3.739635E+00, +3.845884E+00, +3.948993E+00, +4.049100E+00, +4.146336E+00,
                               +4.240822E+00],
                       'B06': [-9.196900E+00, -8.271835E+00, -7.430549E+00, -6.662152E+00, -5.957566E+00,
                               -5.309157E+00, -4.710464E+00, -4.155980E+00, -3.640982E+00, -3.161398E+00,
                               -2.713694E+00, -2.294796E+00, -1.902008E+00, -1.532963E+00, -1.185571E+00,
                               -8.579803E-01, -5.485442E-01, -2.557940E-01, +2.158530E-02, +2.847739E-01,
                               +5.348343E-01, +7.727256E-01, +9.993162E-01, +1.215393E+00, +1.421672E+00,
                               +1.618807E+00, +1.807393E+00, +1.987976E+00, +2.161056E+00, +2.327092E+00,
                               +2.486507E+00, +2.639691E+00, +2.787003E+00, +2.928777E+00, +3.065320E+00,
                               +3.196919E+00, +3.323839E+00, +3.446326E+00, +3.564612E+00, +3.678909E+00,
                               +3.789418E+00, +3.896327E+00, +3.999810E+00, +4.100030E+00, +4.197143E+00,
                               +4.291291E+00, +4.382611E+00, +4.471230E+00, +4.557268E+00, +4.640838E+00,
                               +4.722046E+00],
                       'B07': [-6.697647E+00, -5.913329E+00, -5.200203E+00, -4.548999E+00, -3.951986E+00,
                               -3.402670E+00, -2.895554E+00, -2.425955E+00, -1.989857E+00, -1.583799E+00,
                               -1.204779E+00, -8.501838E-01, -5.177245E-01, -2.053903E-01, +8.859355E-02,
                               +3.657993E-01, +6.276249E-01, +8.753174E-01, +1.109993E+00, +1.332652E+00,
                               +1.544198E+00, +1.745444E+00, +1.937126E+00, +2.119914E+00, +2.294413E+00,
                               +2.461179E+00, +2.620716E+00, +2.773488E+00, +2.919918E+00, +3.060396E+00,
                               +3.195281E+00, +3.324903E+00, +3.449568E+00, +3.569557E+00, +3.685131E+00,
                               +3.796534E+00, +3.903989E+00, +4.007706E+00, +4.107880E+00, +4.204692E+00,
                               +4.298312E+00, +4.388898E+00, +4.476599E+00, +4.561553E+00, +4.643889E+00,
                               +4.723731E+00, +4.801193E+00, +4.876381E+00, +4.949399E+00, +5.020341E+00,
                               +5.089297E+00],
                       'B08': [-5.393772E+00, -4.685488E+00, -4.041563E+00, -3.453606E+00, -2.914623E+00,
                               -2.418741E+00, -1.960986E+00, -1.537125E+00, -1.143525E+00, -7.770576E-01,
                               -4.350083E-01, -1.150142E-01, +1.849930E-01, +4.668311E-01, +7.321044E-01,
                               +9.822339E-01, +1.218483E+00, +1.441978E+00, +1.653729E+00, +1.854640E+00,
                               +2.045526E+00, +2.227123E+00, +2.400096E+00, +2.565049E+00, +2.722531E+00,
                               +2.873042E+00, +3.017039E+00, +3.154940E+00, +3.287128E+00, +3.413955E+00,
                               +3.535744E+00, +3.652795E+00, +3.765383E+00, +3.873762E+00, +3.978168E+00,
                               +4.078819E+00, +4.175920E+00, +4.269658E+00, +4.360209E+00, +4.447737E+00,
                               +4.532395E+00, +4.614326E+00, +4.693662E+00, +4.770530E+00, +4.845046E+00,
                               +4.917319E+00, +4.987455E+00, +5.055549E+00, +5.121692E+00, +5.185972E+00,
                               +5.248467E+00],
                       'B09': [-4.152924E+00, -3.522212E+00, -2.948538E+00, -2.424498E+00, -1.943915E+00,
                               -1.501597E+00, -1.093148E+00, -7.148175E-01, -3.633916E-01, -3.609581E-02,
                               +2.694756E-01, +5.554193E-01, +8.235713E-01, +1.075545E+00, +1.312767E+00,
                               +1.536500E+00, +1.747866E+00, +1.947869E+00, +2.137406E+00, +2.317283E+00,
                               +2.488224E+00, +2.650886E+00, +2.805861E+00, +2.953686E+00, +3.094852E+00,
                               +3.229804E+00, +3.358948E+00, +3.482659E+00, +3.601276E+00, +3.715115E+00,
                               +3.824464E+00, +3.929589E+00, +4.030735E+00, +4.128129E+00, +4.221983E+00,
                               +4.312491E+00, +4.399834E+00, +4.484179E+00, +4.565684E+00, +4.644495E+00,
                               +4.720748E+00, +4.794571E+00, +4.866081E+00, +4.935391E+00, +5.002606E+00,
                               +5.067822E+00, +5.131132E+00, +5.192622E+00, +5.252374E+00, +5.310464E+00,
                               +5.366964E+00],
                       'B10': [-3.176599E+00, -2.605619E+00, -2.086368E+00, -1.612120E+00, -1.177264E+00,
                               -7.770856E-01, -4.075924E-01, -6.538174E-02, +2.524649E-01, +5.484644E-01,
                               +8.247996E-01, +1.083373E+00, +1.325849E+00, +1.553692E+00, +1.768194E+00,
                               +1.970501E+00, +2.161631E+00, +2.342492E+00, +2.513898E+00, +2.676579E+00,
                               +2.831193E+00, +2.978332E+00, +3.118534E+00, +3.252285E+00, +3.380028E+00,
                               +3.502168E+00, +3.619072E+00, +3.731077E+00, +3.838492E+00, +3.941602E+00,
                               +4.040666E+00, +4.135926E+00, +4.227603E+00, +4.315903E+00, +4.401014E+00,
                               +4.483114E+00, +4.562366E+00, +4.638921E+00, +4.712920E+00, +4.784495E+00,
                               +4.853770E+00, +4.920858E+00, +4.985867E+00, +5.048897E+00, +5.110042E+00,
                               +5.169390E+00, +5.227024E+00, +5.283022E+00, +5.337457E+00, +5.390397E+00,
                               +5.441908E+00],
                       'B11': [-2.237206E+00, -1.727252E+00, -1.263441E+00, -8.397752E-01, -4.512537E-01,
                               -9.367158E-02, +2.365320E-01, +5.423928E-01, +8.265148E-01, +1.091145E+00,
                               +1.338231E+00, +1.569471E+00, +1.786352E+00, +1.990181E+00, +2.182112E+00,
                               +2.363168E+00, +2.534258E+00, +2.696195E+00, +2.849703E+00, +2.995435E+00,
                               +3.133978E+00, +3.265861E+00, +3.391564E+00, +3.511522E+00, +3.626129E+00,
                               +3.735746E+00, +3.840701E+00, +3.941295E+00, +4.037804E+00, +4.130479E+00,
                               +4.219555E+00, +4.305244E+00, +4.387745E+00, +4.467241E+00, +4.543900E+00,
                               +4.617879E+00, +4.689323E+00, +4.758368E+00, +4.825139E+00, +4.889753E+00,
                               +4.952320E+00, +5.012941E+00, +5.071712E+00, +5.128720E+00, +5.184052E+00,
                               +5.237783E+00, +5.289989E+00, +5.340738E+00, +5.390095E+00, +5.438121E+00,
                               +5.484873E+00]
                       },
              'MSG4': {'B04': [-2.383162E+01, -2.215616E+01, -2.063047E+01, -1.923522E+01, -1.795429E+01,
                               -1.677411E+01, -1.568320E+01, -1.467175E+01, -1.373134E+01, -1.285472E+01,
                               -1.203558E+01, -1.126843E+01, -1.054846E+01, -9.871418E+00, -9.233576E+00,
                               -8.631611E+00, -8.062572E+00, -7.523821E+00, -7.012998E+00, -6.527980E+00,
                               -6.066856E+00, -5.627900E+00, -5.209547E+00, -4.810377E+00, -4.429098E+00,
                               -4.064531E+00, -3.715600E+00, -3.381319E+00, -3.060782E+00, -2.753159E+00,
                               -2.457682E+00, -2.173645E+00, -1.900397E+00, -1.637333E+00, -1.383894E+00,
                               -1.139560E+00, -9.038490E-01, -6.763121E-01, -4.565311E-01, -2.441154E-01,
                               -3.870079E-02, +1.600536E-01, +3.524667E-01, +5.388375E-01, +7.194464E-01,
                               +8.945568E-01, +1.064416E+00, +1.229257E+00, +1.389300E+00, +1.544750E+00,
                               +1.695804E+00],
                       'B05': [-1.180242E+01, -1.074651E+01, -9.785037E+00, -8.905869E+00, -8.098858E+00,
                               -7.355459E+00, -6.668426E+00, -6.031576E+00, -5.439597E+00, -4.887904E+00,
                               -4.372514E+00, -3.889956E+00, -3.437186E+00, -3.011526E+00, -2.610610E+00,
                               -2.232340E+00, -1.874848E+00, -1.536466E+00, -1.215701E+00, -9.112118E-01,
                               -6.217887E-01, -3.463399E-01, -8.387643E-02, +1.664996E-01, +4.056050E-01,
                               +6.341847E-01, +8.529195E-01, +1.062433E+00, +1.263296E+00, +1.456035E+00,
                               +1.641133E+00, +1.819038E+00, +1.990160E+00, +2.154881E+00, +2.313555E+00,
                               +2.466510E+00, +2.614050E+00, +2.756458E+00, +2.893999E+00, +3.026919E+00,
                               +3.155447E+00, +3.279800E+00, +3.400178E+00, +3.516769E+00, +3.629751E+00,
                               +3.739290E+00, +3.845542E+00, +3.948654E+00, +4.048764E+00, +4.146002E+00,
                               +4.240491E+00],
                       'B06': [-9.204957E+00, -8.279861E+00, -7.438506E+00, -6.670012E+00, -5.965307E+00,
                               -5.316764E+00, -4.717927E+00, -4.163292E+00, -3.648139E+00, -3.168396E+00,
                               -2.720533E+00, -2.301475E+00, -1.908529E+00, -1.539327E+00, -1.191780E+00,
                               -8.640369E-01, -5.544512E-01, -2.615543E-01, +1.596853E-02, +2.792976E-01,
                               +5.294952E-01, +7.675206E-01, +9.942417E-01, +1.210446E+00, +1.416850E+00,
                               +1.614106E+00, +1.802810E+00, +1.983508E+00, +2.156700E+00, +2.322845E+00,
                               +2.482367E+00, +2.635655E+00, +2.783068E+00, +2.924941E+00, +3.061581E+00,
                               +3.193273E+00, +3.320284E+00, +3.442861E+00, +3.561233E+00, +3.675615E+00,
                               +3.786207E+00, +3.893196E+00, +3.996758E+00, +4.097055E+00, +4.194243E+00,
                               +4.288465E+00, +4.379856E+00, +4.468545E+00, +4.554651E+00, +4.638288E+00,
                               +4.719561E+00],
                       'B07': [-6.689264E+00, -5.905441E+00, -5.192767E+00, -4.541973E+00, -3.945336E+00,
                               -3.396365E+00, -2.889567E+00, -2.420262E+00, -1.984438E+00, -1.578634E+00,
                               -1.199851E+00, -8.454766E-01, -5.132245E-01, -2.010849E-01, +9.271610E-02,
                               +3.697496E-01, +6.314127E-01, +8.789515E-01, +1.113481E+00, +1.336003E+00,
                               +1.547418E+00, +1.748540E+00, +1.940104E+00, +2.122778E+00, +2.297171E+00,
                               +2.463834E+00, +2.623273E+00, +2.775951E+00, +2.922292E+00, +3.062684E+00,
                               +3.197487E+00, +3.327030E+00, +3.451618E+00, +3.571535E+00, +3.687039E+00,
                               +3.798374E+00, +3.905764E+00, +4.009418E+00, +4.109532E+00, +4.206286E+00,
                               +4.299850E+00, +4.390382E+00, +4.478030E+00, +4.562933E+00, +4.645221E+00,
                               +4.725015E+00, +4.802431E+00, +4.877575E+00, +4.950550E+00, +5.021450E+00,
                               +5.090365E+00],
                       'B08': [-5.394548E+00, -4.686255E+00, -4.042318E+00, -3.454347E+00, -2.915349E+00,
                               -2.419449E+00, -1.961677E+00, -1.537797E+00, -1.144179E+00, -7.776932E-01,
                               -4.356257E-01, -1.156135E-01, +1.844115E-01, +4.662671E-01, +7.315576E-01,
                               +9.817038E-01, +1.217969E+00, +1.441481E+00, +1.653247E+00, +1.854173E+00,
                               +2.045074E+00, +2.226685E+00, +2.399672E+00, +2.564638E+00, +2.722133E+00,
                               +2.872657E+00, +3.016666E+00, +3.154579E+00, +3.286778E+00, +3.413617E+00,
                               +3.535417E+00, +3.652479E+00, +3.765077E+00, +3.873466E+00, +3.977881E+00,
                               +4.078542E+00, +4.175652E+00, +4.269399E+00, +4.359959E+00, +4.447495E+00,
                               +4.532162E+00, +4.614100E+00, +4.693445E+00, +4.770320E+00, +4.844843E+00,
                               +4.917124E+00, +4.987267E+00, +5.055367E+00, +5.121518E+00, +5.185803E+00,
                               +5.248306E+00],
                       'B09': [-4.165475E+00, -3.534078E+00, -2.959771E+00, -2.435144E+00, -1.954017E+00,
                               -1.511193E+00, -1.102272E+00, -7.235010E-01, -3.716625E-01, -4.397971E-02,
                               +2.619554E-01, +5.482413E-01, +8.167158E-01, +1.068995E+00, +1.306505E+00,
                               +1.530510E+00, +1.742135E+00, +1.942384E+00, +2.132154E+00, +2.312253E+00,
                               +2.483406E+00, +2.646270E+00, +2.801437E+00, +2.949447E+00, +3.090788E+00,
                               +3.225908E+00, +3.355214E+00, +3.479079E+00, +3.597846E+00, +3.711827E+00,
                               +3.821312E+00, +3.926568E+00, +4.027841E+00, +4.125357E+00, +4.219328E+00,
                               +4.309949E+00, +4.397400E+00, +4.481851E+00, +4.563457E+00, +4.642366E+00,
                               +4.718714E+00, +4.792627E+00, +4.864226E+00, +4.933622E+00, +5.000919E+00,
                               +5.066215E+00, +5.129602E+00, +5.191167E+00, +5.250992E+00, +5.309153E+00,
                               +5.365721E+00],
                       'B10': [-3.180482E+00, -2.609305E+00, -2.089870E+00, -1.615448E+00, -1.180430E+00,
                               -7.800984E-01, -4.104612E-01, -6.811489E-02, +2.498596E-01, +5.459800E-01,
                               +8.224296E-01, +1.081111E+00, +1.323689E+00, +1.551630E+00, +1.766224E+00,
                               +1.968619E+00, +2.159833E+00, +2.340774E+00, +2.512256E+00, +2.675010E+00,
                               +2.829692E+00, +2.976898E+00, +3.117163E+00, +3.250975E+00, +3.378776E+00,
                               +3.500971E+00, +3.617929E+00, +3.729985E+00, +3.837450E+00, +3.940607E+00,
                               +4.039717E+00, +4.135020E+00, +4.226739E+00, +4.315080E+00, +4.400230E+00,
                               +4.482368E+00, +4.561656E+00, +4.638246E+00, +4.712279E+00, +4.783888E+00,
                               +4.853194E+00, +4.920313E+00, +4.985351E+00, +5.048410E+00, +5.109583E+00,
                               +5.168958E+00, +5.226618E+00, +5.282641E+00, +5.337101E+00, +5.390065E+00,
                               +5.441599E+00],
                       'B11': [-2.214261E+00, -1.705887E+00, -1.243505E+00, -8.211397E-01, -4.338050E-01,
                               -7.731047E-02, +2.518932E-01, +5.568315E-01, +8.401003E-01, +1.103939E+00,
                               +1.350289E+00, +1.580843E+00, +1.797083E+00, +2.000313E+00, +2.191682E+00,
                               +2.372210E+00, +2.542804E+00, +2.704272E+00, +2.857338E+00, +3.002653E+00,
                               +3.140801E+00, +3.272310E+00, +3.397658E+00, +3.517279E+00, +3.631566E+00,
                               +3.740878E+00, +3.845543E+00, +3.945860E+00, +4.042104E+00, +4.134528E+00,
                               +4.223362E+00, +4.308821E+00, +4.391101E+00, +4.470386E+00, +4.546842E+00,
                               +4.620626E+00, +4.691884E+00, +4.760749E+00, +4.827348E+00, +4.891796E+00,
                               +4.954203E+00, +5.014670E+00, +5.073292E+00, +5.130158E+00, +5.185352E+00,
                               +5.238951E+00, +5.291028E+00, +5.341653E+00, +5.390890E+00, +5.438799E+00,
                               +5.485440E+00]
                       }
              }


def metadata_to_datetime(metadata):
    '''
    Use information from metadata to get image datetime.
    '''
    date_str = '{0:04d}{1:03d}{2:04d}'.format(metadata['src_year'][0],
                                              metadata['src_day'][0],
                                              metadata['src_hour'][0])
    return datetime.strptime(date_str, '%Y%j%H%M')


def _get_geolocation_metadata(metadata):
    geo_md = {}
    geo_md['scene'] = 'Full-Disk'
    geo_md['num_lines'] = metadata['pif_l'][0]
    geo_md['num_samples'] = metadata['pif_c'][0]
    geo_md['sample_res'] = metadata['nav_cres_real'][0]
    geo_md['line_res'] = metadata['nav_lres_real'][0]
    geo_md['sample_off'] = metadata['nav_coff_real'][0]
    geo_md['line_off'] = metadata['nav_loff_real'][0]
    geo_md['lat_off'] = metadata['nav_goff_lat'][0] / 1e3
    geo_md['lon_off'] = metadata['nav_goff_lon'][0] / 1e3

    return geo_md


def satellite_coord_to_geographic(x, y):
    '''
    Converts satellite coordinates to latitudes and longitudes.

    +-----------+---------+------------------------------------------------------------------------+
    | Parameter | Type    | Description                                                            |
    +===========+=========+========================================================================+
    | x         | ndarray | A numpy array containing the x coordinates of a SEVIRI satellite image |
    |           |         | expressed as number of pixels from nadir with zero at nadir, positive  |
    |           |         | east of nadir, and negative west of nadir.                             |
    +-----------+---------+------------------------------------------------------------------------+
    | y         | ndarray | A numpy array containing the x coordinates of a SEVIRI satellite image |
    |           |         | expressed as number of pixels from nadir with zero at nadir, positive  |
    |           |         | north of nadir, and negative south of nadir.                           |
    +-----------+---------+------------------------------------------------------------------------+

    Returns arrays of latitudes and longitudes in degrees.  Resulting arrays are the same shape as
    the input arrays.  Pixels off of the earth's disk are set to -999.0.
    '''
    # Constants
    R0 = 42164.0  # Distance from center of earth to satellite
    Re = 6378.140  # Equatorial radius of earth
    Rp = 6356.755  # Polar radius of earth
    pi = np.pi
    deg2rad = pi / 180.0
    rad2deg = 180.0 / pi

    # Convert coordinates to satellite angles and calculate tangents
    tanas = np.tan(360.0 * deg2rad * x / 50.0)
    tanal = np.tan(360.0 * deg2rad * y / 50.0)

    # Calculate components of an arbitrary vector from the spacecraft in the viewing direction
    p = -1.0
    q = tanas
    r = tanal * np.sqrt(1.0 + q**2)

    # The location of the point on the earth can be identified by solving the quadratic equation
    # for the intersection between the earth's surface and the viewing line from the spacecraft.
    # If this equation has no real roots, then there is no intersection; otherwise the required
    # root is the one nearer to the spacecraft (on the visible side of the earth).
    a = q**2 + (r * Re / Rp)**2 + p**2
    b = 2.0 * R0 * p
    c = R0**2 - Re**2

    # Calculate determinant.  if it is negative (no real roots to quadratic equation)
    # there is no intersection between the line of sight and the disc and so the pixel
    # does not correspond to the visible area.
    det = b**2 - 4 * a * c
    mask = np.zeros(x.shape, dtype=np.bool)
    mask[np.where(det <= 0.0)] = True

    # Calculate lats and lons
    log.info('The following warning is fine.  There are zeros in the square root when off of the earth\'s disk.')
    k = (-b - np.sqrt(det)) / (2 * a)
    x = R0 + k * p
    y = k * q
    z = k * r
    lons = np.arctan(y / x)
    geolat = np.arctan(z * np.cos(lons) / x)

    # Geolat is the geocentric latitude.  Convert it to geodetic (or geographic) latitude
    # before returning
    lats = np.arctan(np.tan(geolat) / ((Rp / Re)**2))

    # Convert from radians to degrees
    lats = rad2deg * lats
    lons = rad2deg * lons
    lats[mask] = -999.0
    lons[mask] = -999.0

    return lats, lons


# def get_satellite_subpoint(num_lines, num_samples, line_off, sample_off, line_res, sample_res):
#     '''
#     Get the subpoint for the satellite described by the input metadata in latitude and longitude as degrees.
#
#     +-------------+---------------------------------------------------------------------+
#     | Parameters  | Description                                                         |
#     +=============+=====================================================================+
#     | num_lines   | Number of pixels in the north/south direction.                      |
#     +-------------+---------------------------------------------------------------------+
#     | num_samples | Number of pixels in the east/west direction.                        |
#     +-------------+---------------------------------------------------------------------+
#     | line_off    | Number of pixels from the equator to the southern most pixel.       |
#     +-------------+---------------------------------------------------------------------+
#     | sample_off  | Number of pixels from the prime meridian to the western most pixel. |
#     +-------------+---------------------------------------------------------------------+
#     | line_res    | Resolution of pixels in some unknown units. Need to figure out.     |
#     +-------------+---------------------------------------------------------------------+
#     | sample_res  | Resolution of pixels in some unknown units. Need to figure out.     |
#     +-------------+---------------------------------------------------------------------+
#     '''
#
#     x = np.array((sample_res * ((num_samples / 2) - sample_off),))
#     y = np.array((line_res * ((num_lines / 2) - line_off),))
#
#     return satellite_coord_to_geographic(x, y)


def calculate_resolution(num_lines, num_samples, line_res, sample_res):
    '''
    Return the resolution of the data at nadir in kilometers.
    '''
    x = sample_res * np.array([num_samples / 2 + 1]) / 1e6
    # y = line_res * np.array([num_lines / 2]) / 1e6
    # coords = satellite_coord_to_geographic(x, y)
    # Angle of arc from nadir to one pixel from nadir times the equatorial circumference
    # gives the data resolution
    res = (x[0] / 360.0) * 2 * np.pi * 6378.140
    return res


# def get_latitude_longitude(num_lines, num_samples, line_off, sample_off,
#                            line_res, sample_res, lat_off, lon_off):
#     '''
#     Calculate the latitudes and longitudes for a Meteosat Second Generation image based on
#     the number of lines and samples, the offsets in number of pixels from 0N, 0E to the south-western
#     most pixel, and the resolution of the pixels in some unknown units.
# 
#     Latitudes and longitudes are returned as ndarrays in the shape `(num_lines, num_samples)`.
#     Pixels that are off of the Earth's disk are set to -999.0.
# 
#     +-------------+---------------------------------------------------------------------+
#     | Parameters  | Description                                                         |
#     +=============+=====================================================================+
#     | num_lines   | Number of pixels in the north/south direction.                      |
#     +-------------+---------------------------------------------------------------------+
#     | num_samples | Number of pixels in the east/west direction.                        |
#     +-------------+---------------------------------------------------------------------+
#     | line_off    | Number of pixels from the equator to the southern most pixel.       |
#     +-------------+---------------------------------------------------------------------+
#     | sample_off  | Number of pixels from the prime meridian to the western most pixel. |
#     +-------------+---------------------------------------------------------------------+
#     | line_res    | Resolution of pixels in some unknown units. Need to figure out.     |
#     +-------------+---------------------------------------------------------------------+
#     | sample_res  | Resolution of pixels in some unknown units. Need to figure out.     |
#     +-------------+---------------------------------------------------------------------+
#     | lat_off     | Latitude offset from 0 in degrees.                                  |
#     +-------------+---------------------------------------------------------------------+
#     | lon_off     | Longitude offset from 0 in degrees.                                 |
#     +-------------+---------------------------------------------------------------------+
#     '''
#     # Create cartesian grid
#     log.info('    LATLONCALC Creating cartesian grid')
#     # x, y = np.meshgrid(np.arange(first_sample, last_sample, sample_step),
#     #                    np.arange(first_line, last_line, line_step))
#     y, x = np.mgrid[1:(num_lines + 1):1, 1:(num_samples + 1):1]
#     # y, x = np.mgrid[0:num_lines:1, 0:num_samples:1]
#     x = sample_res * (x.astype(np.float64) - sample_off) / 1e6
#     y = line_res * (np.flipud(y).astype(np.float64) - line_off) / 1e6
#     log.info('    LATLONCALC After grid creation')
# 
#     lats, lons = satellite_coord_to_geographic(x, y)
# 
#     # Add latitude and longitude offsets
#     # Need to correct for out of range longitudes (Shouldn't happen for MSG)
#     # Would need to correct for other sensors using this method
#     lats += lat_off
#     lons += lon_off
#     return lats, lons


def get_latitude_longitude(metadata):
    '''
    This routine accepts a dictionary containing metadata as read from an XPIF format file
    and returns latitudes and longitudes for a full disk.
    '''
    # If the filename format needs to change for the pre-generated geolocation
    # files, please discuss prior to changing.  It will force recreation of all
    # files, which can be problematic for large numbers of sectors
    fname = get_geolocation_cache_filename('GEOLL', metadata)
    if not os.path.isfile(fname):
        if DONT_AUTOGEN_GEOLOCATION:
            msg = ('GETGEO Requested NO AUTOGEN GEOLOCATION. ' +
                   'Could not create latlonfile for ad {}: {}').format(metadata['scene'], fname)
            log.error(msg)
            raise AutoGenError(msg)

        log.debug('Calculating latitudes and longitudes.')

        y, x = np.mgrid[1:(metadata['num_lines'] + 1):1, 1:(metadata['num_samples'] + 1):1]
        x = metadata['sample_res'] * (x.astype(np.float64) - metadata['sample_off']) / 1e6
        y = metadata['line_res'] * (np.flipud(y).astype(np.float64) - metadata['line_off']) / 1e6
        lats, lons = satellite_coord_to_geographic(x, y)
        lats += metadata['lat_off']
        lons += metadata['lon_off']
        log.info('Done calculating latitudes and longitudes')

        with open(fname, 'w') as df:
            lats.tofile(df)
            lons.tofile(df)

    # Create memmap to the lat/lon file
    # Nothing will be read until explicitly requested
    # We are mapping this here so that the lats and lons are available when calculating satellite angles
    log.info('GETGEO memmap to {} : lat/lon file for {}'.format(fname, metadata['scene']))
    shape = (metadata['num_lines'], metadata['num_samples'])
    offset = 8 * metadata['num_samples'] * metadata['num_lines']
    lats = np.memmap(fname, mode='r', dtype=np.float64, offset=0, shape=shape)
    lons = np.memmap(fname, mode='r', dtype=np.float64, offset=offset, shape=shape)

    return lats, lons


# def calculate_satellite_angles(metadata, lats, lons):
#     '''
#     This routine accepts a dictionary containing metadata as read from an XPIF data file and
#     return latitudes and longitudes for a full disk image.
# 
#     Note: This code has been adapted from Stan Kidder's F90 code.
#     '''
#     log.debug('Calculating satellite zenith and azimuth angles.')
#     pi = np.pi
#     deg2rad = pi / 180.0
#     rad2deg = 180.0 / pi
#     sat_alt = 42164.0  # Distance from center of earth to satellite
#     # num_lines = metadata['num_lines']
#     # num_samples = metadata['num_samples']
#     sub_lat = metadata['lat_off']
#     sub_lon = metadata['lon_off']
# 
#     # Convert lats/lons to radians from sub point
#     log.info('   SATCALC Calculating beta')
#     beta = np.arccos(np.cos(deg2rad * (lats - sub_lat)) * np.cos(deg2rad * (lons - sub_lon)))
# 
#     bad = lats <= -999.0
# 
#     # Calculate satellite zenith angle
#     log.info('    SATCALC Calculating satellite zenith angle')
#     sat_zen = sat_alt * np.sin(beta) / np.sqrt(1.808e9 - 5.3725e8 * np.cos(beta))
#     sat_zen = rad2deg * np.arcsin(np.clip(sat_zen, -1.0, 1.0))
#     sat_zen[bad] = lats[bad]
# 
#     # Sat azimuth
#     # Sat azimuth
#     log.info('    SATCALC Calculating satellite azimuth angle')
#     sat_azm = np.sin(deg2rad * (lons - sub_lon)) / np.sin(beta)
#     numexpr.evaluate('rad2deg * arcsin(where(sat_azm < -1.0, -1.0, where(sat_azm > 1.0, 1.0, sat_azm)))', out=sat_azm)
#     sat_azm = rad2deg * np.arcsin(np.clip(sat_azm, -1.0, 1.0))
#     sat_azm[lats < sub_lat] = 180.0 - sat_azm[lats < sub_lat]
#     sat_azm[sat_azm < 0.0] += 360.0
#     sat_azm[bad] = lats[bad]
# 
#     log.debug('Done calculating satellite zenith and azimuth angles')
#     return sat_zen, sat_azm


def get_satellite_angles(metadata, lats, lons):
    # If the filename format needs to change for the pre-generated geolocation
    # files, please discuss prior to changing.  It will force recreation of all
    # files, which can be problematic for large numbers of sectors
    fname = get_geolocation_cache_filename('GEOSAT', metadata)
    if not os.path.isfile(fname):
        if DONT_AUTOGEN_GEOLOCATION:
            msg = ('GETGEO Requested NO AUTOGEN GEOLOCATION. ' +
                   'Could not create sat_file for ad {}: {}').format(metadata['scene'], fname)
            log.error(msg)
            raise AutoGenError(msg)

        log.info('Calculating satellite zenith and azimuth angles.')
        pi = np.pi
        deg2rad = pi / 180.0
        rad2deg = 180.0 / pi
        sat_alt = 42164.0  # Distance from center of earth to satellite

        sub_lat = metadata['lat_off']
        sub_lon = metadata['lon_off']

        # Convert lats/lons to radians from sub point
        log.info('   SATCALC Calculating beta')
        beta = np.arccos(np.cos(deg2rad * (lats - sub_lat)) * np.cos(deg2rad * (lons - sub_lon)))

        bad = lats <= -999.0

        # Calculate satellite zenith angle
        log.info('    SATCALC Calculating satellite zenith angle')
        sat_zen = sat_alt * np.sin(beta) / np.sqrt(1.808e9 - 5.3725e8 * np.cos(beta))
        sat_zen = rad2deg * np.arcsin(np.clip(sat_zen, -1.0, 1.0))
        sat_zen[bad] = lats[bad]

        # Sat azimuth
        # Sat azimuth
        log.info('    SATCALC Calculating satellite azimuth angle')
        sat_azm = np.sin(deg2rad * (lons - sub_lon)) / np.sin(beta)
        numexpr.evaluate('rad2deg * arcsin(where(sat_azm < -1.0, -1.0, where(sat_azm > 1.0, 1.0, sat_azm)))',
                         out=sat_azm)
        sat_azm = rad2deg * np.arcsin(np.clip(sat_azm, -1.0, 1.0))
        sat_azm[lats < sub_lat] = 180.0 - sat_azm[lats < sub_lat]
        sat_azm[sat_azm < 0.0] += 360.0
        sat_azm[bad] = lats[bad]

        log.debug('Done calculating satellite zenith and azimuth angles')

        with open(fname, 'w') as df:
            sat_zen.tofile(df)
            sat_azm.tofile(df)

    # Create a memmap to the lat/lon file
    # Nothing will be read until explicitly requested
    # We are mapping this here so that the lats and lons are available when calculating satlelite angles
    log.info('GETGEO memmap to {} : lat/lon file for {}'.format(fname, metadata['scene']))
    shape = (metadata['num_lines'], metadata['num_samples'])
    offset = 8 * metadata['num_samples'] * metadata['num_lines']
    zen = np.memmap(fname, mode='r', dtype=np.float64, offset=0, shape=shape)
    azm = np.memmap(fname, mode='r', dtype=np.float64, offset=offset, shape=shape)

    return zen, azm


def get_indexes(metadata, lats, lons, sect):
    '''
    Return two 2-D arrays containing the X and Y indexes that should be used from the raw data
    for the input sector definition.
    '''
    # The get_neighbor_info function returns three four arrays:
    #    valid_input_index: a 1D boolean array indicating where the source lats and lons
    #                       are valid values (not masked)
    #    valid_output_index: a 1D boolean array indicating where the sector lats and lons
    #                        are valid values (always true everywhere)
    #    index_array: a 1D array of ints indicating which indicies in the flattened inputs
    #                 should be used to fit the sector lats and lons
    #    distance_array: Distances from the source point for each found point.
    #
    # What we do here is feed our data lats/lons to get_neighbour_info.
    # We then reshape valid_input_index to fit our lats/lons and find the 2D indicies where
    #   the input lats and lons were good.
    # We then subset the "good" indicies with index_array to retrieve the required indicies for
    #   the sector.
    # This is complicated because get_neighbour_info does not report the indicies of the
    #   input data, but instead reports the indicies of the flattened data where valid_input_index
    #   is True

    # Get filename for sector indicies

    # If the filename format needs to change for the pre-generated geolocation
    # files, please discuss prior to changing.  It will force recreation of all
    # files, which can be problematic for large numbers of sectors
    fname = get_geolocation_cache_filename('GEOINDS', metadata, sect)

    if not os.path.isfile(fname):
        if DONT_AUTOGEN_GEOLOCATION:
            msg = ('GETGEO Requested NO AUTOGEN GEOLOCATION. ' +
                   'Could not create inds_file {} for {}').format(fname, sect.name)
            log.error(msg)
            raise AutoGenError(msg)

        # Allocate the full disk area definition
        log.info('    GETGEOINDS Creating full disk swath definition for {}'.format(sect.name))
        fldk_ad = SwathDefinition(np.ma.masked_less(lons, -999.1), np.ma.masked_less(lats, -999.1))
        ad = sect.area_definition

        # Radius of influence will be 10 times the nominal spatial resolution of the data
        #   in meters
        # This uses the only piece of information available concerning resolution in the metadata
        log.info('    GETGEOINDS Calculating radius of influence {}'.format(sect.name))
        roi = 10000
        log.info('    GETGEOINDS Running get_neighbour_info {}'.format(sect.name))
        valid_input_index, valid_output_index, index_array, distance_array = \
            get_neighbour_info(fldk_ad, ad, radius_of_influence=roi, neighbours=1, nprocs=nprocs)
        log.info('    GETGEOINDS Getting good lines and samples {}'.format(sect.name))
        good_lines, good_samples = np.where(valid_input_index.reshape(lats.shape))
        log.info('    GETGEOINDS Reshaping lines and samples {}'.format(sect.name))
        # When get_neighbour_info does not find a good value for a specific location it
        #   fills index_array with the maximum index + 1.  So, just throw away all of the
        #   out of range indexes.
        index_mask = (index_array == len(good_lines))
        # good_index_array = index_array[np.where(index_array != len(good_lines))]
        lines = np.empty(ad.size, dtype=np.int64)
        lines[index_mask] = -999.1
        lines[~index_mask] = good_lines[index_array[~index_mask]]
        samples = np.empty(ad.size, dtype=np.int64)
        samples[index_mask] = -999.1
        samples[~index_mask] = good_samples[index_array[~index_mask]]

        log.info('    GETGEOINDS Writing to {} : inds_file for {}'.format(fname, sect.name))
        # Store indicies for sector
        with open(str(fname), 'w') as df:
            lines.tofile(df)
            samples.tofile(df)

    # Create a memmap to the lat/lon file
    # Nothing will be read until explicitly requested
    # We are mapping this here so that the lats and lons are available when calculating satlelite angles
    log.info('GETGEO memmap to {} : inds file for {}'.format(fname, metadata['scene']))
    log.info('GETGEO memmap to {} : lat/lon file for {}'.format(fname, metadata['scene']))
    shape = sect.area_definition.shape
    offset = 8 * shape[0] * shape[1]
    lines = np.memmap(fname, mode='r', dtype=np.int64, offset=0, shape=shape)
    samples = np.memmap(fname, mode='r', dtype=np.int64, offset=offset, shape=shape)
    return lines, samples


def calculate_solar_angles(metadata, lats, lons, dt):
    '''
    This routine accepts a dictionary containing metadata as read from an XPIF data file and
    return latitudes and longitudes for a full disk image.

    Note: This code has been adapted from Stan Kidder's F90 code.
    '''
    debug = False

    log.debug('Calculating solar zenith and azimuth angles.')

    # Constants
    pi = np.pi
    pi2 = 2 * pi  # NOQA
    num_lines = metadata['num_lines']
    num_samples = metadata['num_samples']
    shape = (num_lines, num_samples)  # NOQA
    size = num_lines * num_samples  # NOQA
    deg2rad = pi / 180.0  # NOQA
    rad2deg = 180.0 / pi  # NOQA

    # Calculate any non-data dependent quantities
    jday = float(dt.strftime('%j'))
    a1 = (1.00554 * jday - 6.28306) * (pi / 180.0)
    a2 = (1.93946 * jday - 23.35089) * (pi / 180.0)
    et = -7.67825 * np.sin(a1) - 10.09176 * np.sin(a2)  # NOQA

    # Solar declination radians
    log.debug('Calculating delta')
    delta = deg2rad * 23.4856 * np.sin(np.deg2rad(0.9683 * jday - 78.00878))  # NOQA

    # Pre-generate sin and cos of latitude
    log.debug('Calculating sin and cos')
    sin_lat = np.sin(deg2rad * lats)  # NOQA
    cos_lat = np.cos(deg2rad * lats)  # NOQA

    # Hour angle
    log.debug('Initializing hour angle')
    solar_time = dt.hour + dt.minute / 60.0 + dt.second / 3600.0  # NOQA
    h_ang = numexpr.evaluate('deg2rad*((solar_time + lons / 15.0 + et / 60.0 - 12.0) * 15.0)')

    # Pre-allocate all required arrays
    # This avoids having to allocate them again every time the generator is accessed
    log.debug('Allocating arrays')
    sun_elev = np.empty_like(h_ang)

    # Hour angle at all points in radians
    log.debug('Calculating hour angle')

    # Sun elevation
    log.debug('Calculating sun elevation angle using sin and cos')
    numexpr.evaluate('arcsin(sin_lat * sin(delta) + cos_lat * cos(delta) * cos(h_ang))', out=sun_elev)  # NOQA

    log.debug('Calculating caz')
    # No longer need sin_lat and this saves 3.7GB
    if not debug:
        caz = sin_lat
    else:
        caz = np.empty_like(sin_lat)
    numexpr.evaluate('-cos_lat * sin(delta) + sin_lat * cos(delta) * cos(h_ang) / cos(sun_elev)', out=caz)  # NOQA

    log.debug('Calculating az')
    # No longer need h_ang and this saves 3.7GB
    if not debug:
        az = h_ang
    else:
        az = np.empty_like(h_ang)
    numexpr.evaluate('cos(delta)*sin(h_ang)/cos(sun_elev)', out=az)  # NOQA
    # No longer need sin_lat and this saves 3.7GB
    if not debug:
        sun_azm = cos_lat
    else:
        sun_azm = np.empty_like(cos_lat)
    numexpr.evaluate('where(az <= -1, -pi/2.0, where(az > 1, pi/2.0, arcsin(az)))', out=sun_azm)

    log.debug('Calculating solar zenith angle')
    # No longer need sun_elev and this saves 3.7GB RAM
    if not debug:
        sun_zen = sun_elev
    else:
        sun_zen = np.empty_like(sun_elev)
    numexpr.evaluate('90.0-rad2deg*sun_elev', out=sun_zen)

    log.debug('Calculating solar azimuth angle')
    numexpr.evaluate('where(caz <= 0, pi - sun_azm, where(az <= 0, 2.0 * pi + sun_azm, sun_azm))', out=sun_azm)
    sun_azm += pi
    numexpr.evaluate('where(sun_azm > 2.0 * pi, sun_azm - 2.0 * pi, sun_azm)', out=sun_azm)
    # numexpr.evaluate('where(caz <= 0, pi - sun_azm, sun_azm) + pi', out=sun_azm)
    # numexpr.evaluate('rad2deg * where(sun_azm < 0, sun_azm + pi2, where(sun_azm >= pi2, sun_azm - pi2, sun_azm))',
    #             out=sun_azm)
    log.debug('Done calculating solar zenith and azimuth angles')

    return sun_zen, sun_azm


def get_geolocation_cache_filename(pref, metadata, sect=None):
    '''
    Set the location and filename format for the pre-generated cached geolocation files.
    There is a separate filename for satellite lat/lons and sector lat/lons.
    If the filename format needs to change for the pre-generaged geolocation files,
    please discuss prior to changing.  It will force receation of all files,
    which can be problematic for large numbers of sectors
    '''
    cache = GEOLOCDIR
    if sect and sect.isdynamic:
        cache = DYNAMIC_GEOLOCDIR
    if not os.path.isdir(cache):
        os.makedirs(cache)

    md_hash = hash(frozenset((k, v) for k, v in metadata.items() if isinstance(v, Hashable)))

    fname = "{}_{}_{}x{}".format(pref,
                                 metadata['scene'],
                                 metadata['num_lines'],
                                 metadata['num_samples'],
                                 )

    # If the filename format needs to change for the pre-generated geolocation
    # files, please discuss prior to changing.  It will force recreation of all
    # files, which can be problematic for large numbers of sectors

    if sect:
        ad = sect.area_definition
        log.info('    Using area_definition information for hash: {}'.format(str(ad.proj_dict.items())))
        sector_hash = hash(frozenset(ad.proj_dict.items()))
        sect_nlines = ad.shape[0]
        sect_nsamples = ad.shape[1]
        sect_clat = sect.area_info.center_lat_float
        sect_clon = sect.area_info.center_lon_float
        fname += '_{}_{}x{}_{}x{}'.format(sect.name,
                                          sect_nlines,
                                          sect_nsamples,
                                          sect_clat,
                                          sect_clon)
        fname += "_{}_{}".format(md_hash, sector_hash)
    else:
        fname += "_{}".format(md_hash)

    fname += '.dat'

    # Check alternative read-only directories (i.e. operational)
    for dirname in READ_GEOLOCDIRS:
        if os.path.exists(os.path.join(dirname, fname)):
            return os.path.join(dirname, fname)

    # If not found, return the normal cached filename
    return os.path.join(cache, fname)


def get_geolocation(dt, metadata, sect=None):
    '''
    Gather and return the geolocation data for the input metadata.
    Input metadata should be the metadata for a single SEVIRI data file.

    If latitude/longitude have not been calculated with the metadata from the input data file
    they will be recalculated and stored for future use.  They shouldn't change often.
    This will be slow the first time it is called after a metadata update, but fast thereafter.

    The same is true for satellite zenith and azimuth angles.

    Solar zenith and azimuth angles are always calculated on the fly.
    This is because they actually change.
    This may be slow for full-disk images.
    '''
    adname = 'None'
    if sect:
        adname = sect.name
    # Get the metadata we need
    gmd = _get_geolocation_metadata(metadata)

    try:
        fldk_lats, fldk_lons = get_latitude_longitude(gmd)
        fldk_sat_zen, fldk_sat_azm = get_satellite_angles(gmd, fldk_lats, fldk_lons)
    except AutoGenError:
        return False

    # Determine which indicies will be needed for the input sector if there is one.
    if sect is not None:
        try:
            lines, samples = get_indexes(gmd, fldk_lats, fldk_lons, sect)
        except AutoGenError:
            return False

        # Get lats, lons, and satellite zenith and azimuth angles for the required points
        # This may not be entirely appropriate, especially if we want to do something better than
        # nearest neighbor interpolation.
        shape = sect.area_definition.shape
        index_mask = (lines != -999.1)

        lons = np.full(shape, -999.1)
        lats = np.full(shape, -999.1)
        sat_zen = np.full(shape, -999.1)
        sat_azm = np.full(shape, -999.1)

        lons[index_mask] = fldk_lons[lines[index_mask], samples[index_mask]]
        lats[index_mask] = fldk_lats[lines[index_mask], samples[index_mask]]
        sat_zen[index_mask] = fldk_sat_zen[lines[index_mask], samples[index_mask]]
        sat_azm[index_mask] = fldk_sat_azm[lines[index_mask], samples[index_mask]]

    else:
        lats = fldk_lats
        lons = fldk_lons
        sat_zen = fldk_sat_zen
        sat_azm = fldk_sat_azm

    # Get generator for solar zenith and azimuth angles
    log.info('GETGEO Must calculate solar zen/azm for sector {}'.format(adname))
    sun_zen, sun_azm = calculate_solar_angles(gmd, lats, lons, dt)

    log.info('GETGEO Done calculating solar zen/azm for sector {}'.format(adname))
    sun_zen = np.ma.masked_less_equal(sun_zen, -999.1)
    sun_azm = np.ma.masked_less_equal(sun_azm, -999.1)

    # Make into a dict
    geolocation = {'Latitude': np.ma.masked_less_equal(lats, -999.1),
                   'Longitude': np.ma.masked_less_equal(lons, -999.1),
                   'SatZenith': np.ma.masked_less_equal(sat_zen, -999.1),
                   'SatAzimuth': np.ma.masked_less_equal(sat_azm, -999.1),
                   'SunZenith': np.ma.masked_less_equal(sun_zen, -999.1),
                   'SunAzimuth': np.ma.masked_less_equal(sun_azm, -999.1)}

    try:
        geolocation['Lines'] = np.array(lines)
        geolocation['Samples'] = np.array(samples)
    except NameError:
        pass

    return geolocation

# def get_geolocation(dt, metadata, sector_definition=None):
#     '''
#     Gather and return the geolocation data for the input metadata.
#     Input metadata should be the metadata for a single SEVIRI data file.
# 
#     If latitude/longitude have not been previously calculated with the exact metadata provided,
#     they will be recalculated and stored for future use.  The metadata shouldn't change often,
#     mostly when the satellite is moved.  The same is true for satellite zenith and azimuth angles.
# 
#     Solar zenith and azimuth angles are always calculated on the fly.  This is because they change
#     based on time of day.  This may be slow for full-disk images.
#     '''
#     try:
#         adname = sector_definition.name
#     except AttributeError:
#         adname = 'undefined'
# 
#     sensor = 'seviri'
# 
#     # Get geolocation metadata
#     gmd = _get_geolocation_metadata(metadata)
# 
#     # These don't change unless the metadata changes, so keep an archive of these with a hash of the metadata
#     # This uses a hash of the required metadata to create a unique file name based only on the metadata
#     # so that if the metadata ever change, we will know to recalculate.
#     # metadata_hash = hash(frozenset(gmd.items()))
# 
#     # latlon_fname = '{0}_{1}x{2}_{3}.DAT'.format('GEOLL', gmd['num_lines'], gmd['num_samples'], metadata_hash)
#     # sat_fname = '{0}_{1}x{2}_{3}.DAT'.format('GEOSAT', gmd['num_lines'], gmd['num_samples'], metadata_hash)
#     gmd['sensor'] = 'seviri'
#     latlon_fname = get_geolocation_filename(sensor, 'GEOLL', gmd)
#     sat_fname = get_geolocation_filename(sensor, 'GEOSAT', gmd)
#     geolocdir = os.path.dirname(latlon_fname)
# 
#     # Make the geolocation directory
#     if not os.path.isdir(geolocdir):
#         os.makedirs(geolocdir)
# 
#     # If they haven't been calculated yet, calculate lats and lons
#     if not os.path.isfile(latlon_fname):
#         if DONT_AUTOGEN_GEOLOCATION:
#             log.error('GETGEO Requested NO AUTOGEN GEOLOCATION. ' +
#                       'Could not create latlon_fname for ad {}: {}'.format(adname, latlon_fname))
#             return False
#         # Calculate lats and lons
#         log.info('GETGEO Must calculate latitudes and longitudes for full disk')
#         lats, lons = calculate_latitude_longitude(gmd['num_lines'], gmd['num_samples'],
#                                                   gmd['line_off'], gmd['sample_off'],
#                                                   gmd['line_res'], gmd['sample_res'],
#                                                   gmd['lat_off'], gmd['lon_off'])
# 
#         with open(latlon_fname, 'w') as ll_df:
#             lats.tofile(ll_df)
#             lons.tofile(ll_df)
# 
#     # Create a memmap to the lat/lon file
#     # Note that nothing will be read until explicitly requested (later)
#     # We are mapping this here so that the lats and lons are available when caludlating satellite angles
#     log.info('GETGEO memmap to {0} : lat/lon file for {1}'.format(latlon_fname, adname))
#     shape = (gmd['num_lines'], gmd['num_samples'])
#     offset = 8 * gmd['num_lines'] * gmd['num_samples']
#     lats = np.memmap(latlon_fname, mode='r', dtype=np.float64, offset=0, shape=shape)
#     lons = np.memmap(latlon_fname, mode='r', dtype=np.float64, offset=offset, shape=shape)
# 
#     if not os.path.isfile(sat_fname):
#         if DONT_AUTOGEN_GEOLOCATION:
#             log.error('GETGEO Requested NO AUTOGEN GEOLOCATION. ' +
#                       'Could not create sat_file for ad {0}: {1}'.format(adname, sat_fname))
#             return False
#         # Calculate satellite angles
#         log.info('GETGEO Must calculate sat zen/azm for sector {}'.format(adname))
#         sat_zen, sat_azm = calculate_satellite_angles(gmd, lats, lons)
#         with open(sat_fname, 'w') as sat_df:
#             sat_zen.tofile(sat_df)
#             sat_azm.tofile(sat_df)
# 
#     # Read the archived satellite angle data
#     log.info('GETGEO memmap to {0} : archived satellite angle data for {1}'.format(sat_fname, adname))
#     # Here, df.shape is for one segment.
#     # The full image should be the second element of shape squared.
#     sat_zen = np.memmap(sat_fname, mode='r', dtype=np.float64, offset=0, shape=shape)
#     sat_azm = np.memmap(sat_fname, mode='r', dtype=np.float64, offset=offset, shape=shape)
# 
#     # Determine which indicies will be needed for the sector if there is one.
#     # If there is no sector, we'll just use everything.
#     # The get_neighbor_info function returns four arrays:
#     #    valid_input_index: a 1D boolean array indicating where the source lats and lons
#     #                       are valid values (not masked)
#     #    valid_output_index: a 1D boolean array indicating where the sector lats and lons
#     #                        are valid values (always true everywhere)
#     #    index_array: a 1D array of ints indicating which indicies in the flattened inputs
#     #                 should be used to fit the sector lats and lons
#     #    distance_array: Distances from the source point for each found point.
#     #
#     # What we do here is feed our data lats/lons to get_neighbour_info.
#     # We then reshape valid_input_index to fit our lats/lons and find the 2D indicies where
#     #   the input lats and lons were good.
#     # We then subset the "good" indicies with index_array to retrieve the required indicies for
#     #   the sector.
#     # This is complicated because get_neighbour_info does not report the indicies of the
#     #   input data, but instead reports the indicies of the flattened data where valid_input_index
#     #   is True
#     # Get filename for sector indicies
#     if sector_definition is not None:
#         ad = sector_definition.area_definition
#         inds_file = get_geolocation_filename('seviri', 'GEOINDS', gmd, sector_definition)
#         # Check for archived version
#         if not os.path.isfile(inds_file):
#             if DONT_AUTOGEN_GEOLOCATION:
#                 log.error(
#                     'GETGEO Requested NO AUTOGEN GEOLOCATION. Could not create inds_file {0} for {1}'.format(
#                         inds_file, adname))
#                 return False
#             log.info('GETGEO Calculating indexes required for %s sector.' % adname)
#             log.info('        This will take some time, but will only be done once per sector unless ' +
#                      ' the sector is changed or the AHI full disk metadata changes.')
# 
#             # Allocate the full disk area definition
#             log.info('    GETGEOINDS Creating full disk swath definition for {}'.format(adname))
#             fldk_ad = SwathDefinition(np.ma.masked_less_equal(lons, -999.0),
#                                       np.ma.masked_less_equal(lats, -999.0))
# 
#             nprocs = 1
# 
#             # Radius of influence will be 10 times the nominal spatial resolution of the data in meters
#             res = calculate_resolution(gmd['num_lines'], gmd['num_samples'], gmd['line_res'], gmd['sample_res'])
#             roi = 10000 * res
#             log.info('    GETGEOINDS Running get_neighbour_info {}'.format(adname))
#             valid_input_index, valid_output_index, index_array, distance_array = \
#                 get_neighbour_info(fldk_ad, ad, radius_of_influence=roi, neighbours=1, nprocs=nprocs)
#             log.info('    GETGEOINDS Getting good lines and samples {}'.format(adname))
#             good_lines, good_samples = np.where(valid_input_index.reshape(lats.shape))
#             log.info('    GETGEOINDS Reshaping lines and samples {}'.format(adname))
#             # When get_neighbour_info does not find a good value for a specific location it
#             #   fills index_array with the maximum index + 1.  So, just throw away all of the
#             #   out of range indexes.
#             index_mask = (index_array == len(good_lines))
#             lines = np.empty(ad.size, dtype=np.int64)
#             samples = np.empty(ad.size, dtype=np.int64)
#             lines[index_mask] = -999.1
#             samples[index_mask] = -999.1
#             lines[~index_mask] = good_lines[index_array[~index_mask]]
#             samples[~index_mask] = good_samples[index_array[~index_mask]]
# 
#             log.info('    GETGEOINDS Writing to {0} : inds_file for {1}'.format(inds_file, adname))
#             # Store indicies for sector
#             with open(str(inds_file), 'w') as inds_df:
#                 lines.tofile(inds_df)
#                 samples.tofile(inds_df)
# 
#         # Read the archived indexes for this sector
#         log.info('GETGEO memmap to {0} : archived indexes for {1}'.format(inds_file, adname))
#         sect_lines = np.memmap(inds_file, mode='r', dtype=np.int64, offset=0, shape=ad.shape)
#         sect_samples = np.memmap(inds_file, mode='r', dtype=np.int64, offset=(8 * ad.size), shape=ad.shape)
# 
#         # Get lats, lons, and satellite zenith and azimuth angles for required points
#         # This may not be entirely appropriate, especially if we want to do something better than
#         # nearest neighbor interpolation.
#         sect_lons, sect_lats = ad.get_lonlats()
#         index_mask = (sect_lines == -999.1)
#         sect_sat_zen = np.empty(ad.shape)
#         sect_sat_zen[index_mask] = -999.1
#         sect_sat_zen[~index_mask] = sat_zen[sect_lines[~index_mask], sect_samples[~index_mask]]
#         sect_sat_azm = np.empty(ad.shape)
#         sect_sat_azm[index_mask] = -999.1
#         sect_sat_azm[~index_mask] = sat_azm[sect_lines[~index_mask], sect_samples[~index_mask]]
#     else:
#         sect_lats = lats
#         sect_lons = lons
#         # sect_sat_zen = sat_zen
#         # sect_sat_azm = sat_azm
#         sect_lines = None
#         sect_samples = None
# 
#     # Get generator for solar zenith and azimuth angles
#     log.info('GETGEO Must calculate solar zen/azm for sector {}'.format(adname))
#     sect_sun_zen, sect_sun_azm = calculate_solar_angles(gmd, sect_lats, sect_lons, dt)
#     log.info('GETGEO Done calculating solar zen/azm for sector {}'.format(adname))
#     sect_sun_zen = np.ma.masked_less_equal(sect_sun_zen, -999.1)
#     sect_sun_azm = np.ma.masked_less_equal(sect_sun_azm, -999.1)
# 
#     sect_lats = np.ma.masked_less_equal(sect_lats, -999.1)
#     sect_lons = np.ma.masked_less_equal(sect_lons, -999.1)
#     sect_sat_zen = np.ma.masked_less_equal(sect_sat_zen, -999.1)
#     sect_sat_azm = np.ma.masked_less_equal(sect_sat_azm, -999.1)
#     sect_sun_zen = np.ma.masked_less_equal(sect_sun_zen, -999.1)
#     sect_sun_azm = np.ma.masked_less_equal(sect_sun_azm, -999.1)
# 
#     # Make into a dict
#     geolocation = {'Latitude': sect_lats,
#                    'Longitude': sect_lons,
#                    'SatZenith': sect_sat_zen,
#                    'SatAzimuth': sect_sat_azm,
#                    'SunZenith': sect_sun_zen,
#                    'SunAzimuth': sect_sun_azm,
#                    'Lines': np.array(sect_lines),
#                    'Samples': np.array(sect_samples)}
# 
#     return geolocation


def _get_metadata(df, **kwargs):
    '''
    Gather metadata for the data file and return as a dictionary.
    '''
    # Info describing header data
    # Key: field name
    # Value: dict containing bit length and data type
    # Changed to use position rather than assume everything is contiguous.
    # Some gaps exist in the metadata it seems...
    md_info = {'pif_k': {'name': 'Bytes per pixel',
                         'type': np.int8,
                         'bytes': 1,
                         'pos': 0},
               'pif_n': {'name': 'Records per line',
                         'type': np.int16,
                         'bytes': 2,
                         'pos': 1},
               'pif_l': {'name': 'Number of lines',
                         'type': np.int32,
                         'bytes': 4,
                         'pos': 3},
               'pif_c': {'name': 'Number of columns',
                         'type': np.int32,
                         'bytes': 4,
                         'pos': 7},
               'pif_ext': {'name': 'Number of additional header records',
                           'type': np.int8,
                           'bytes': 1,
                           'pos': 11},
               'pif_comp': {'name': 'Compression function',
                            'type': np.int8,
                            'bytes': 1,
                            'pos': 12},
               'pif_ahx': {'name': 'Number of additional header extension records',
                           'type': np.int16,
                           'bytes': 2,
                           'pos': 13},
               'pif_nb': {'name': 'Number of bits per pixel',
                          'type': np.int8,
                          'bytes': 1,
                          'pos': 15},
               'nav_func': {'name': 'Navigation function code',
                            'type': np.int8,
                            'bytes': 1,
                            'pos': 16},
               'nav_loff': {'name': 'Line offset',
                            'type': np.int32,
                            'bytes': 4,
                            'pos': 17},
               'nav_coff': {'name': 'Column offset',
                            'type': np.int32,
                            'bytes': 4,
                            'pos': 21},
               'nav_lres': {'name': 'Line resolution',
                            'type': np.int32,
                            'bytes': 4,
                            'pos': 25},
               'nav_cres': {'name': 'Column resolution',
                            'type': np.int32,
                            'bytes': 4,
                            'pos': 29},
               # Something wrong here
               'nav_goff_lon': {'name': 'Longitude offset in mdeg',
                                'type': np.int32,
                                'bytes': 4,
                                'pos': 33},
               # Something wrong here
               'nav_goff_lat': {'name': 'Latitude offset in mdeg',
                                'type': np.int32,
                                'bytes': 4,
                                'pos': 37},
               # Something wrong here
               'nav_split_line': {'name': 'For split lines: first line of split',
                                  'type': np.int32,
                                  'bytes': 4,
                                  'pos': 41},
               # Something wrong here
               'nav_split_coff': {'name': 'For split scans: new NAV_COFF after split',
                                  'type': np.int32,
                                  'bytes': 4,
                                  'pos': 45},
               # Something wrong here
               'nav_loff_real': {'name': 'Line offset as double',
                                 'type': np.float64,
                                 'bytes': 8,
                                 'pos': 49},
               # Something wrong here
               'nav_coff_real': {'name': 'Column offset as double',
                                 'type': np.float64,
                                 'bytes': 8,
                                 'pos': 57},
               # Something wrong here
               'nav_lres_real': {'name': 'Line resolution as double',
                                 'type': np.float64,
                                 'bytes': 8,
                                 'pos': 65},
               # Something wrong here
               'nav_cres_real': {'name': 'Column resolution as double',
                                 'type': np.float64,
                                 'bytes': 8,
                                 'pos': 73},
               # Something wrong here
               'nav_use_reals': {'name': 'Flag indicating if real paramters should be used',
                                 'type': str,
                                 'bytes': 16,
                                 'pos': 81},
               # 'nav_sp': {'name': 'Spare, set to 0',
               #            'type': np.int8,
               #            'bytes': 31,
               #            'pos': 97},
               'dat_f': {'name': 'Greylevel function',
                         'type': np.int8,
                         'bytes': 1,
                         'pos': 128},
               'dat_nam': {'name': 'Data name (ASCII)',
                           'type': str,
                           'bytes': 16,
                           'pos': 129},
               'dat_enh': {'name': 'Default Enhancement Function (ASCII)',
                           'type': str,
                           'bytes': 16,
                           'pos': 145},
               'dat_sp': {'name': 'Spare, set to 0',
                          'type': np.int8,
                          'bytes': 29,
                          'pos': 161},
               'dat_toff': {'name': 'Temperature offset',
                            'type': np.int16,
                            'bytes': 2,
                            'pos': 190},
               'src_obj': {'name': 'Image source object (ASCII)',
                           'type': str,
                           'bytes': 16,
                           'pos': 192},
               'src_year': {'name': 'Year (UT) of nominal image time (NIT)',
                            'type': np.int16,
                            'bytes': 2,
                            'pos': 208},
               'src_day': {'name': 'Day of year (UT) of NIT',
                           'type': np.int16,
                           'bytes': 2,
                           'pos': 210},
               'src_hour': {'name': 'Hour x 100 + minute (UT) of NIT',
                            'type': np.int16,
                            'bytes': 2,
                            'pos': 212},
               'src_msg_cals': {'name': 'Calibration slope, set to 0 if not used',
                                'type': np.float64,
                                'bytes': 8,
                                'pos': 214},
               'src_msg_calo': {'name': 'Calibration offset, set to 0 if not used',
                                'type': np.float64,
                                'bytes': 8,
                                'pos': 222},
               'src_version': {'name': 'File format version "xPIFvv.r"',
                               'type': str,
                               'bytes': 8,
                               'pos': 248}
               }

    # Read the header
    metadata = {}
    for mdname, mdinfo in md_info.items():
        dtype = mdinfo['type']
        size = mdinfo['bytes']
        pos = mdinfo['pos']
        df.seek(pos)
        dat = df.read(size)
        try:
            metadata[mdname] = np.fromstring(dat, dtype=dtype)
        except ValueError:
            metadata[mdname] = dtype(dat)
    if metadata['pif_ext'] < 0:
        metadata['pif_ext'] = int(metadata['pif_ext']) + 256
    metadata['header_extension'] = df.read(metadata['pif_ext'])
    metadata['fname'] = df.name
    metadata['chan'] = CHANNEL_MAP[metadata['dat_nam'].strip()]

    return metadata


def read_data(metadata, gvars, rad=False, ref=False, bt=False):
    '''
    Read data for the specified channel and convert to the specified data types.
    '''
    print metadata['dat_nam']
    data = {}

    # Determine starting position of data (default header == 256 bytes)
    # Must add extended header length
    start = 256 + 256 * metadata['pif_ext']
    # start = 512
    # Set up memmap to data
    # Notes on shape
    # XPIF is ridiculous.
    # Lines are composed of `pif_n` number of records.
    # "Records" are 256 bytes long.
    # The end of a record may not match with the end of a line, so we must read past the end of the line
    # until we hit the end of a record before starting to read the next line.
    # So, while an image may only contain 5500 samples per line, we need to read 5632 16 bit integers
    # per line, then only use the first 5500 integers.
    shape = (metadata['pif_l'][0], (256 * metadata['pif_n'][0]) / metadata['pif_k'][0])
    counts = np.memmap(metadata['fname'], offset=start, dtype=np.int16, shape=shape)
    # Trim off any extra pixels on the end of each line (should be on the right side
    # Appears only to occur for HRV
    if 'Lines' not in gvars:
        counts = counts[0:metadata['pif_l'][0], 0:metadata['pif_c'][0]]
    else:
        counts = counts[gvars['Lines'], gvars['Samples']]

    # Set out of range values to bad values
    counts[counts < 0] = -999.0
    counts[counts >= 1024] = -999.0

    # Convert to radiances
    scl = metadata['src_msg_cals']
    off = metadata['src_msg_calo']
    radiance = scl * counts + off

    # Gather metadata info for conversions to Ref and BT
    plat = metadata['src_obj'][0:4]
    chan = metadata['chan']
    doy = metadata['src_day'][0]
    esd = 1.0 - 0.0167 * np.cos(6.2831853 * (doy - 3) / 365)

    # Find all bad values of radiance
    bad = radiance < 0

    # If we want radiance, store them
    if rad:
        radiance[bad] = 0
        data['Rad'] = np.ma.array(radiance)
        # data['Rad'] = np.ma.array(radiance, mask=bad)
    if ref:
        try:
            plat_rad2ref = CAL_RAD2REF[plat]
        except KeyError:
            raise ValueError('Unrecognized platform: {}'.format(plat))
        try:
            rad2ref = plat_rad2ref[chan]
        except KeyError:
            raise ValueError('Not a recognized reflectance channel: {}'.format(chan))
        data['Ref'] = np.ma.array(100.0 * esd**2 * (radiance / rad2ref))
        # data['Ref'] = np.ma.array(100.0 * esd**2 * (radiance / rad2ref), mask=bad)
    if bt:
        try:
            plat_rad2bt = CAL_RAD2BT[plat]
        except KeyError:
            raise ValueError('Unrecognized platform: {}'.format(plat))
        try:
            rad2bt = plat_rad2bt[chan]
        except KeyError:
            raise ValueError('Not a recognized reflectance channel: {}'.format(chan))

        # Set all values less than or equal to zero to the machine epsilon
        # This avoids NaN in log
        radiance[radiance <= 0] = np.finfo(radiance.dtype).eps

        # Set up spline
        spl = interpol.splrep(rad2bt, CAL_EBBT, s=0)
        data['BT'] = np.ma.array(interpol.splev(np.log(radiance), spl, ext=3))
        # data['BT'] = np.ma.array(interpol.splev(np.log(radiance), spl, ext=3), mask=bad)

    return data


def _check_file_consistency(metadata):
    '''
    Checks to be sure that all input metadata are from the same image time.
    '''
    # Check the sensor name
    src_obj = [metadata[fn]['src_obj'] for fn in metadata.keys()]
    if src_obj[1:] != src_obj[:-1]:
        return False

    # Check date and time
    for field_name in ['src_year', 'src_day', 'src_hour']:
        field_dat = [metadata[fn][field_name] for fn in metadata.keys()]
        if field_dat[1:] != field_dat[:-1]:
            return False

    return True


class MSG_XPIF_Reader(Reader):
    channel_map = CHANNEL_MAP
    dataset_info = {# 'HIGH': ['B12'],
                    'LOW': ['B01', 'B02', 'B03', 'B04', 'B05', 'B06', 'B07', 'B08', 'B09', 'B10', 'B11']
                    }
    all_chans = {# 'HIGH': ['B12Rad', 'B12Ref'],
                 'LOW': ['B01Rad', 'B01Ref',
                         'B02Rad', 'B02Ref',
                         'B03Rad', 'B03Ref',
                         'B04Rad', 'B04BT',
                         'B05Rad', 'B05BT',
                         'B06Rad', 'B06BT',
                         'B07Rad', 'B07BT',
                         'B08Rad', 'B08BT',
                         'B09Rad', 'B09BT',
                         'B10Rad', 'B10BT',
                         'B11Rad', 'B11BT'
                         ]
                 }

    @staticmethod
    def decompress_msg(fname, outdir, chans):
        if not os.path.exists(outdir):
            os.makedirs(outdir)

    @staticmethod
    def format_test(fname):
        if os.path.isfile(fname):
            if os.path.splitext(fname)[-1] == '.zip':
                # Get the file names contained in the zip file
                fnames = ZipFile(fname).namelist()

            elif os.path.splitext(fname)[-1].lower() == '.xpif':
                return True

            else:
                return False

        elif os.path.isdir(fname):
            fnames = glob(fname + '/*')

        else:
            return False

        # Test the retrieved filenames to ensure we have at least one XPIF file
        for fn in fnames:
            if os.path.splitext(fn)[-1].lower() == '.xpif':
                return True
        return False

    def read(self, fname, datavars, gvars, scifile_metadata, chans=None, sector_definition=None,
             self_register=False):
        # If we have a zip file, decompress and get the dirname
        if os.path.isfile(fname):
            parts = os.path.splitext(fname)
            if parts[-1] == '.zip':
                dirname = os.path.join(SCRATCH, os.path.basename(parts[0]))
                ZipFile(fname).extractall(dirname)
            elif parts[-1] == '.XPIF':
                fname = [fname]
            else:
                raise ValueError('Format unrecognized {}'.format(parts[-1]))

        elif os.path.isdir(fname):
            dirname = fname

        # Gather all XPIF files in directory
        # Want to skip HRV channel for now
        fnames = [fn for fn in glob(os.path.join(dirname, '*.XPIF')) if 'HRV' not in os.path.basename(fn)]

        # Test inputs
        if sector_definition and self_register:
            raise ValueError('sector_definition and self_register are mutually exclusive keywords')

        # Get metadata for all input files
        all_metadata = {fn: _get_metadata(open(fn, 'r')) for fn in fnames}

        # Check file consistency
        if not _check_file_consistency(all_metadata):
            raise ValueError('Input files inconsistent.')

        # Now put together a dict that shows what we actually got
        # This is largely to help us gather one set of metadata per resolution
        # Dict structure is channel{file}
        file_info = {}
        file_chans = set()
        for md in all_metadata.values():
            ch = self.channel_map[md['dat_nam'].strip()]
            if ch in file_info:
                raise ValueError('Duplicate channel encountered')
            file_info[ch] = md
            file_chans.add(ch)

        # Most of the metadata are the same between files.
        # From here on we will just rely on the metadata from a single file for each resolution
        res_md = {}
        # Skipping HRV for now
        for res in ['LOW']:
            # Find a file for this resolution: Any one will do
            res_chans = list(set(self.dataset_info[res]).intersection(file_info.keys()))
            if res_chans:
                # Get the metadata for whatever channel we just grabbed.  Doesn't matter which.
                res_md[res] = file_info[res_chans[0]]

        # get appropriate sector name
        if sector_definition:
            scifile_metadata['top']['sector_name'] = sector_definition.name
            scifile_metadata['top']['sector_definition'] = sector_definition
        else:
            if self_register and self_register not in self.dataset_info:
                raise ValueError('Unrecognized resolution name requested for self registration: {}'.format(
                    self_register))
            scifile_metadata['top']['sector_name'] = 'Full-Disk'
            scifile_metadata['top']['sector_definition'] = None
        adname = scifile_metadata['top']['sector_name']

        # Gather metadata
        # Assume the same for all resolutions.  Should be close enough.
        highest_md = res_md[res_md.keys()[0]]
        dt = metadata_to_datetime(highest_md)
        scifile_metadata['top']['start_datetime'] = dt
        scifile_metadata['top']['source_name'] = 'seviri'
        scifile_metadata['top']['platform_name'] = highest_md['src_obj'].split('_')[0].lower()
        scifile_metadata['top']['sector_definition'] = sector_definition
        scifile_metadata['top']['NO_GRANULE_COMPOSITES'] = True
        scifile_metadata['top']['SECTOR_ON_READ'] = True

        # If an empty list of channels was requested, just stop here and output the metadata
        if chans == []:
            return

        all_chans_list = []
        for chl in self.all_chans.values():
            all_chans_list += chl

        # If specific channels were requested, check them against input data
        # If a requested channel does not exist, then error
        if chans:
            for chan in chans:
                if chan not in all_chans_list:
                    raise ValueError('Requested channel {0} not recognized.'.format(chan))
                if chan[0:3] not in file_chans:
                    raise ValueError('Requested channel {0} not found in input data'.format(chan))

        # If no specific channels were requested, get everything
        if not chans:
            chans = all_chans_list
        # Creates dict whose keys are band numbers in the form B## and whose values are lists
        # containing the data type(s) requested for the band (e.g. Rad, Ref, BT)
        chan_info = {}
        for ch in chans:
            chn = ch[0:3]
            typ = ch[3:]
            if chn not in chan_info:
                chan_info[chn] = []
            chan_info[chn].append(typ)

        # Gather geolocation data
        # Assume datetime the same for all resolutions.  Not true, but close enough.
        # This saves us from having very slightly different solar angles for each channel.
        # Loop over resolutions and get metadata as needed
        if self_register:
            log.info('')
            log.interactive('Getting geolocation information for {}.'.format(
                self_register, adname))
            gvars[adname] = get_geolocation(dt, res_md[self_register], sector_definition)
            if not gvars[adname]:
                log.error('GEOLOCATION FAILED for {} DONT_AUTOGEN_GEOLOCATION is: {}'.format(
                    adname, DONT_AUTOGEN_GEOLOCATION))
                gvars[adname] = {}
        else:
            for res in ['LOW', 'HIGH']:
                try:
                    res_md[res]
                except KeyError:
                    continue
                log.info('')
                log.interactive('Getting geolocation information for resolution {} for {}'.format(res, adname))
                gvars[res] = get_geolocation(dt, res_md[res], sector_definition)
                if not gvars[res]:
                    log.error('GEOLOCATION FAILED for {} resolution {} DONT_AUTOGEN_GEOLOCATION is: {}'.format(
                        adname, res, DONT_AUTOGEN_GEOLOCATION))
                    gvars[res] = {}

        log.info('Done with geolocation for {}'.format(adname))
        log.info('')

        # Read the data
        # Will read all data if sector definition is None
        # Will only read required data if a sector_definition is provided
        for chan, types in chan_info.items():
            chan_md = file_info[chan]
            for res, res_chans in self.dataset_info.items():
                if chan in res_chans:
                    break
            if (not self_register) and (res not in gvars.keys() or not gvars[res]):
                log.interactive('We don\'t have geolocation for {} for {} skipping {}'.format(
                    res, adname, chan))
                continue
            if not sector_definition:
                dsname = res
            else:
                dsname = adname

            rad = ref = bt = False
            if 'Rad' in types:
                rad = True
            if 'Ref' in types:
                ref = True
            if 'BT' in types:
                bt = True
            if self_register:
                data = read_data(chan_md, gvars[adname], rad, ref, bt)
            else:
                data = read_data(chan_md, gvars[res], rad, ref, bt)
            for typ, val in data.items():
                if dsname not in datavars:
                    datavars[dsname] = {}
                datavars[dsname][chan + typ] = val

        # This needs to be fixed:
        #   remove any unneeded datasets from datavars and gvars
        #   also mask any values below -999.0
        if sector_definition:
            # for res in ['HIGH', 'LOW']:
            for res in ['LOW']:
                if adname not in gvars:
                    gvars[adname] = gvars[res]
                try:
                    gvars.pop(res)
                except KeyError:
                    pass

        if self_register:
            # Determine which resolution has geolocation
            # Currently only handling LOW resolution data
            # See ABI reader to complete this
            log.info('Registering to {}'.format(self_register))
            datavars[adname] = datavars.pop('LOW')
        # Remove lines and samples arrays.  Not needed.
        for res in gvars.keys():
            try:
                gvars[res].pop('Lines')
                gvars[res].pop('Samples')
            except KeyError:
                pass
        #Create data mask
        for ds in datavars.keys():
            if not datavars[ds]:
                datavars.pop(ds)
            else:
                full_mask = np.zeros(gvars[ds]['Latitude'].shape, dtype=np.bool)
                for gvarname in gvars[ds].keys():
                    gvar_mask = gvars[ds][gvarname] <= -999.0
                    full_mask = np.logical_or(full_mask, gvar_mask)
                for gvarname in gvars[ds].keys():
                    gvars[ds][gvarname] = np.ma.array(gvars[ds][gvarname], mask=full_mask)
                for varname in datavars[ds].keys():
                    datavars[ds][varname] = np.ma.array(datavars[ds][varname], mask=full_mask)
        log.interactive('Done reading SEVIRI data for {}'.format(adname))
        log.info('')
